[{"title":"江湖情","url":"/2019/02/06/江湖情/","content":"<p>           \n<center>江湖情不眠，</center>\n<center>把酒对青天。</center>\n<center>若有不平事，</center>\n<center>众君来相见。</center>\n","tags":["人生"]},{"title":"一把小锁走天下","url":"/2018/08/15/一把小锁走天下/","content":"\n**为什么需要锁** \n\n在计算机的世界里，效率是我们追求的关键目标。既然要效率，就要`多核`，`多进程`，`多线程`，`多协程`。\n\n显然，光`多`，是不够的。大家必须被高效调度，才能人心齐，泰山移。`多`产生的一个关键问题就是`并发问题`。\n\n对于一片共享内存空间，大家都来`读`，没事，但是大家同时都来`写`，OK吗？如果OK的话，当然很好。如果不行，`锁`就登场了。\n\n**什么是锁**\n\n`锁`的目标，就是让不安全的并行进行串行化。如果有了锁，所有并行单元，就去拿锁，谁能拿到锁，谁就执行。拿不到锁的自己想办法。这样就保证只有一个执行单元执行。\n\n所以，面对并发问题，我们希望对我们的代码加上一把小锁。那么，怎么才能有锁呢？\n\n**怎么实现锁**\n\n`拿锁`这个动作显然本身也是一个并发问题。我们需要保证只有一个能够拿到锁。这时候，我们需要CPU给我们提供一种安全的`原子操作`机器指令——比如`CAS`。\n\n因为CPU调度、中断的最小单位就是机器指令，所以这个`原子操作`是不会有任何中断的。当然，`原子操作`本身并不是不会被中断。`原子操作`只是不可分割，不可能只执行一半。\n\n执行成功者，即拿到锁，执行失败者，只好自己想办法。\n\n**锁的种类**\n\n锁的本质只有一个。但是锁的衣服可以有千万种。比如：\n\n`Mysql`中，我们经常会提：`乐观锁`、`悲观锁`、`意向锁`、`行锁`、`表锁`、`共享锁`、`排他锁`，`Gap Lock`，`Next-Key Lock`。\n\n`Java`中，我们经常会提：`可重入锁`、`偏向锁`、`轻量级锁`、`重量级锁`、`公平锁`、`非公平锁`、`自旋锁`、`自适应自旋锁`、`分段锁`、`读写锁`。\n\n这么多的锁，只是针对不同的并发场景，为提高并发性能而进行的加锁放锁的策略设计。\n\n**总结**\n\n在并发这个江湖里，得锁者得天下。\n\n\n\n","tags":["并发"]},{"title":"论观书","url":"/2018/07/20/论观书/","content":"\n对于观书，古人有诗：\n```\n观书有感二首\n\n[宋] 朱熹\n\n其一\n半亩方塘一鉴开，天光云影共徘徊。\n问渠那得清如许？为有源头活水来。\n\n其二\n昨夜江边春水生，艨艟巨舰一毛轻。\n向来枉费推移力，此日中流自在行。 \n```\n\n其一，强调多读好书。其二，量变引起质变。道理很简单，大家都懂。\n\n可是，为什么有的人成了大家，有的人成不了大家呢？可能的原因有以下几个：\n```\n读的书太少，或者不爱读书。\n读的书不对，不够系统，甚至读错书，被误人子弟而不自知。\n缺少思考，囫囵吞枣，不得要领。\n一直在重复学习。没有活水，只有死水。\n缺少实践，读过既忘，毫无用处。\n缺少总结，知识不能构成闭环系统。\n```\n\n如何解决？个人愚见：\n```\n寻找经典书籍，进行阅读和学习。\n反复思考和内化，实践，把握本质思想。\n读书须有用武之地。必须大量生产实践，不断总结。\n升华思想，创造创新，有足够积累。\n可以尝试努力写出自己的好书。\n\n```\n","tags":["方法论"]},{"title":"Spring的取名之道","url":"/2018/06/20/Spring的取名之道/","content":"\n取好类名是代码设计的第一步。以spring及spring-boot的代码为参考，学其取名之道。\n\n**取名之道**\n```\n* 通用方式：n x [语意清晰的描述性形容词/名词 ] + [达成共识的实体名词/行为直接描述性名词/设计模式名词]\n    * AnnotationConfigApplication + Context\n    * InitDestroyAnnotationBean + PostProcessor\n    * ListableBean + Factory\n* 对于接口，也可以这样：n x [语意清晰的描述性形容词/名词] + [描述can do的形容词]\n    * ApplicationEventPublisher + Aware\n```\n\n**后缀前缀**\n```\n* 后缀：[基础设计]\n    * 添加名词后缀：\n        * Property\n            * PropertySource\n            * PropertyName\n            * PropertyNameAliases\n            * PropertyState\n    * 名词后缀单数变复数：\n        * ExitCodeGenerator\n            * ExitCodeGenerators\n    * 添加形容词后缀：描述接口\n        * aware：\n            * EnvironmentAware\n* 前缀：[扩展设计]\n    * 添加名词前缀\n        * Resource：\n            * ContextResource\n            * FileUrlResource\n            * ClassPathResource\n    * 添加形容词前缀\n        * 功能限定性：\n            * Configurable\n                * ConfigurableEnvironment\n            * Mutable\n                * MutablePropertySources\n            * ReadOnly\n                * ReadOnlySystemAttributesMap\n        * 特定场景的标准前缀\n            * Abstract/Base\n                * AbstarctEnvironment\n```\n                \n**名词后缀 [行为不明确]**\n```\n* Context\n* Application\n* Result\n    * BindResult\n* Snapshot\n    * FolderSnapshot\n    * FIleSnapshot\n* Event\n* Banner\n* Metadata\n    * ConfigurationBeanFactoryMetadata\n* Property\n    * ConfigurationProperty\n    * ConfigurationProperties\n    * PropertySource\n    * PropertyName\n    * PropertyNameAliases\n    * PropertyState\n* Mapping\n    * PropertyMapping\n* Binding\n    * ConfigurationPropertiesBinding\n* Format\n    * DurationFormat\n* Style\n    * DurationStyle\n* Element\n    * AnsiElement\n* Unit\n    * DataSizeUnit\n* Analysis\n    * FailureAnalysis\n* Resource\n* Origin\n    * PropertySourceOrigin\n* Exception\n* Error\n* Module\n* Component\n* Configuration\n    * RedisAutoConguration\n* Level\n    * LogLevel\n* System\n    * LoggingSystem\n```\n    \n**名词后缀 [行为明确-见名知意]**\n```\n* Listener\n    * SpringApplicationRunListener\n    * ClassPathFileChangeListener\n* Initializer\n    * ContextInitializer\n* Processor\n    * InitDestroyAnnotationBeanPostProcessor\n* Customizer\n    * taskExecutorCustomer\n* Selector\n    * EnableConfigurationPropertiesImportSelector\n* Accessor\n    * EnvironmentAccessor\n    * PropertyAccessor\n    * RedisAccessor\n* Watcher\n    * FileSystemWatcher\n* Stream\n    * ConnectionInputStream\n    * ConnectionOutputStream\n* Runner\n    * ApplicationRunner\n* Converter\n* Generator\n* Handler\n    * ExceptionHandler\n* Reporter\n    * ExceptionReporter\n* Registrar\n    * BeanRegistrar\n    * PostProcessorRegistrar\n* Registry\n* Builder\n    * SpringApplicationBuilder\n* Validator\n* Deducer\n    * ConversionServiceDeducer\n    * PropetySourcesDeducer\n* Mapper\n    * PropertyMapper\n* Binder\n    * ConfigurationPropertiesBinder\n* Filter\n    * UnboundElementsSourceFilter\n    * TypeExcludeFilter\n* Resolver\n    * PlaceHoldersResolver\n* Writer\n    * ApplicationPidFileWriter\n* Service\n    * ApplicationConversionService\n* Formatter\n    * CharArrayFormatter\n* Delimiter\n* Factory\n    * ConverterFactory\n* Analyzer\n    * FailureAnalyzer\n* Loader\n    * PropertiesLoader\n    * BeanDefinitionLoader\n* ClassLoader\n    * TomcatEmbeddedWebappClassLoader\n* Serializer\n* Deserializer\n* Driver\n    * DatabaseDriver\n* Connection\n* Management\n* Manager\n* Provider\n* Supplier\n* Wrapper\n    * XADataSourceWrapper\n* Parser\n    * JsonParser\n* Comparator\n    * ConfigurationComparator\n* Configurator\n    * LogbackConfigurator\n* Strategy\n    * SpringPhysicalNamingStrategy\n* Matcher\n* Starter\n    * TomcatStarter\n* Uploader\n* Trigger\n* Interceptor\n* Dispatcher\n* Condition\n* Launcher\n    * RestarterLauncher\n* Forwarder\n    * HttpTunnelPayloadForwarder\n* Extractor\n    * RemoteUrlPropertyExtractor\n* Finder\n    * AnnotatedClassFinder\n* BootStrapper\n    * SpringBootTestContextBootStrapper\n* Collector\n    * MetadataCollector\n```\n    \n**形容词后缀**\n```\n* aware：\n    * EnvironmentAware\n    * ApplicationContextAware\n    * ApplicationEventPublisherAware\n```\n","tags":["设计"]},{"title":"类图厉器","url":"/2018/06/13/类图厉器/","content":"\n一直在寻找好用的UML类图工具。今日在浏览IDEA的官网plugin排行榜时，发现了一款个人迄今为止觉得最好的工具：`Code Navigator`. \n\n它的使用分为三个部分：\n```\n    class cloud diagram ——> 分析选中范围内所有类的依赖关系，生成class的云图\n    graphical navigation between dependent classes ——> 云图上搜索类，可以选择该类，展示其所有依赖和被依赖的类关系\n    creation of UML diagrams ——> 用户添加自己感兴趣的类到UML图中。然后对这些类按照用户选择进行类关系自动关联\n```\n\n该版本目前在官网上声明支持`IDEA 2016.3`。不过在笔者的`IDEA 2018.2.2`版本上也运行良好。\n\n下面是一张`spring-data-redis`中`RedisTemplate`通过code navigator自动生成的类关系图。\n\n![RedisTemplate.jpg](https://upload-images.jianshu.io/upload_images/1401040-7103516f2fb7b085.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n","tags":["工具"]},{"title":"面向工程 or 面向刨根","url":"/2018/05/18/面向工程-or-面向刨根/","content":"\n作为一名码农，当面对一个问题时，我们通常有两种解决方式。一个是以结果为导向，能够解决这个问题就好，不去深究原因。称这种为`面向工程`。另一种则是深究其来龙去脉，然后再去解决问题。称之为`面向刨根`。\n\n当面对紧急线上问题时，自然是`面向工程`，最快解决问题最好，然后再事后进行RCA。但是通常情况下，我们都应该`面向刨根`，深入理解问题的本质。\n\n如果，对于所有的问题，我们只求解决，而不去刨根，不管磨炼多少年，终究只是一个码农熟练工而已。只有具有刨根精神，日积月累，方能成为一方专家。\n\n以我本人的教训而言，在技术学习路上，其实就走了不少弯路。我自认为是一个具有刨根精神的人，我相信大多人都是。但是在起初，当我们知识体系比较薄弱的时候，需要深究一个问题时，会面临不少困难。正所谓”万事开头难”。当困难重重时，那么，很多人就退出了。我的脑袋中就有很多的问号，但是很长一段时间，很难把问号消灭掉。\n\n凡事都要迎难而上。没有解决不了的问题。更何况其实绝大部分问题，都已经有人解决过了。会google，会读书，会实践，会思考。基本没有弄不清楚的问题。\n\n所以，在时间允许的情况下，必须面向刨根。即使当前时间不允许，事后也要进行刨根。最开始，会很慢。但越往后，越快。\n\n显而易见，`面向刨根`，是成为大牛的必由之路。\n","tags":["方法论"]},{"title":"设计模式之我见","url":"/2018/05/10/设计模式之我见/","content":"一个优秀的程序员必然要写的一手好代码。好代码的判定标准就是良好的可读性与扩展性。业界常提的`七大设计原则`和`23种设计模式`即是代码的最佳实践和设计指南。其实，设计模式也并非只有23种。请看[此处](https://github.com/iluwatar/java-design-patterns)。\n\n对于这些原则和设计模式，需要把握其本质，并应用到我们的生产实践当中。本质是什么呢？简而言之，即：`面向接口`。当我们针对一个实际问题进行代码设计时，实际上主要回答下面的问题：\n```\n需要设计几个接口？ —— 开放封闭原则：哪些地方可能需要扩展，哪些地方就定义接口\n接口的职责是什么？ —— 单一职责原则 & 接口隔离原则\n接口如何进行组合？ —— 组合/聚合复用原则 & 依赖倒置原则\n```\n\n可以说，设计模式正是基于这些好的设计原则对上面三个问题的经典回答。这些设计模式，其中有些基本是一样的，也不必死抠概念，刻意区分，关键是理解本质，灵活运用。最常用的是下面几个：\n\n```\nProxy Pattern\nAdapter Pattern\nFacade Pattern\nStategy Pattern\nObserver Pattern\nChain of Responsibility Pattern\nCommand Pattern\n```\n\n在我看来，`设计模式`还有一个重要作用，就是告诉我们怎么给接口`命名`。作为一名程序员，`命名`是一个技术活儿。这种`命名`是约定共识。当命名确定下来，职责划分也就确定了下来。\n\n以最常用的`Observer Pattern`为例，我们通常的命名会是`xxListener`, 又或者是`xxObserver`。只看这个名字，我们就知道这个类是干什么的了。\n","tags":["观点"]},{"title":"巨人之肩","url":"/2018/05/01/巨人之肩/","content":"书籍、经典开源代码，就是`巨人之肩`。然而，知识无限，书籍庞杂。个人所及，稍作清单整理。\n\n**书籍**\n```\n大基本功：\n* 操作系统 —— 精髓与设计原理[William]\n* 深入Linux内核架构[Wolfgang]\n* 微计算机原理\n* 计算机网络\n* TCP/IP详解卷1/2\n* UNIX网络编程卷1/2\n* 数据结构[王红梅等]\n* 算法导论[Thomas等]\n\n开发语言：\n* C程序设计[谭浩强]\n* 程序员的自我修养\n* 深入理解Java虚拟机\n* 揭秘Java虚拟机(JVM设计原理与实现)\n* 深入理解JVM & G1GC\n* Java编程思想\n* Java并发编程实战\n* Go语言编程[许式伟]\n* 码出高效-Java开发手册\n* 设计模式之禅\n* 重构-改善既有代码的设计\n* Python源码剖析\n* Fluent Python[Luciano Ramalho]\n\n应用实践：\n* 鸟哥的Linux私房菜\n* Mysql技术内幕-InnoDB存储引擎\n* 高性能Mysql\n* Redis设计与实现\n* 亿级流量网站架构核心技术\n* 深入理解Spark-核心思想与源码分析\n* 从Paxos到Zookeeper\n* Spring源码深度解析\n* 开源项目的官方文档及源码\n\n机器学习：\n* 机器学习[周志华]\n* 深度学习[Ian等]\n* 美团机器学习实践\n* 高等数学\n* 概率论与数理统计\n* 线性代数\n\n软件架构：\n* 领域驱动设计-软件核心复杂性应对之道\n* 架构即未来：现代企业可扩展的Web架构、流程及组织\n* 微服务设计\n\n哲学与方法论：\n* 程序员修炼之道——从小工到专家\n* 80/20法则\n* 高效人士的七个习惯\n```\n\n**OSS**\n```\n* Java系\n    * Spring/spring-boot/Spring-cloud\n    * Tomcat\n    * Netty\n    * Zookeeper\n    * kafka\n    * rocketMQ\n    * Spark\n    * Elasticsearch\n* Python系\n    * Gunicorn\n    * Flask\n    * gevent\n    * Twisted\n    * Tornado\n* C系\n    * Linux\n    * JVM\n    * Redis\n    * Nginx\n    * libevent/libev\n```\n","tags":["方法论"]},{"title":"类加载小记","url":"/2018/04/30/类加载小记/","content":"\n类加载的控制逻辑(loadClass)： ——> java.lang.ClassLoader#loadClass\n\n* findLoadedClass // 检查是否已经被加载\n* loadClass // 使用parent class loader进行加载\n* findClass // 进行自定义的路径加载\n* resolveClass // 根据入参true或者false，进行动态链接。\n\n线程默认类加载器：\n\n* AppClassLoader ——> 继承URLClassLoader \n\n* 双亲委派模式：AppClassLoader ——> ExtClassLoader ——> bootClassLoader\n\nAppClassLoader的类层次结构：\n\n* ClassLoader\n* SecureClassLoader\n* URLClassLoader\n* AppClassLoader\n\n类加载的关键方法：\n\n* loadClass // 定义加载的控制逻辑\n* findClass // 定义寻找的控制逻辑\n* defineClass // 将二进制数据转换成一个class对象\n\n自定义类加载器举例：spring-boot-devtools#RestartClassLoader\n\n* 重写findClass、loadClass\n* 重写getResources、getResource、findResource\n\n<img max-width=100% src=\"https://upload-images.jianshu.io/upload_images/1401040-5a4e8cd04a742741.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500\"/>\n\n反序列化 VS 类加载：\n\n(1) 类加载：二进制到class——> java.lang.ClassLoader#defineClass\n```\n/**\n * 将一个ByteBuffer转换成一个class\n*/\nprotected final Class<?> defineClass(String name, java.nio.ByteBuffer b,\n                                     ProtectionDomain protectionDomain)\n    throws ClassFormatError\n{\n    int len = b.remaining();\n\n    // Use byte[] if not a direct ByteBufer:\n    if (!b.isDirect()) {\n        if (b.hasArray()) {\n            return defineClass(name, b.array(),\n                               b.position() + b.arrayOffset(), len,\n                               protectionDomain);\n        } else {\n            // no array, or read-only array\n            byte[] tb = new byte[len];\n            b.get(tb);  // get bytes out of byte buffer.\n            return defineClass(name, tb, 0, len, protectionDomain);\n        }\n    }\n\n    protectionDomain = preDefineClass(name, protectionDomain);\n    String source = defineClassSourceLocation(protectionDomain);\n    // native 方法\n    Class<?> c = defineClass2(name, b, b.position(), len, protectionDomain, source);\n    postDefineClass(c, protectionDomain);\n    return c;\n}\n```\n\n(2) 反序列化：类加载 + 实例化。\n\n默认类加载器 ——> java.io.ObjectInputStream#resolveClass\n```\nprotected Class<?> resolveClass(ObjectStreamClass desc)\n    throws IOException, ClassNotFoundException\n{\n    String name = desc.getName();\n    try {\n        // latestUserDefinedLoader() == AppClassLoader\n        return Class.forName(name, false, latestUserDefinedLoader());\n    } catch (ClassNotFoundException ex) {\n        Class<?> cl = primClasses.get(name);\n        if (cl != null) {\n            return cl;\n        } else {\n            throw ex;\n        }\n    }\n}\n```\n\n配置自定义类加载器 ——> org.springframework.core#ConfigurableObjectInputStream\n```\nprotected Class<?> resolveClass(ObjectStreamClass classDesc) throws IOException, ClassNotFoundException {\n   try {\n      if (this.classLoader != null) {\n         // Use the specified ClassLoader to resolve local classes.\n         return ClassUtils.forName(classDesc.getName(), this.classLoader);\n      }\n      else {\n         // Use the default ClassLoader...\n         return super.resolveClass(classDesc);\n      }\n   }\n   catch (ClassNotFoundException ex) {\n      return resolveFallbackIfPossible(classDesc.getName(), ex);\n   }\n}\n```\n","tags":["java"]},{"title":"字节码生成ASM","url":"/2018/04/17/字节码生成ASM/","content":"\n关于这个话题，有一篇文章不错。原文见[AOP 的利器：ASM 3.0 介绍](https://www.ibm.com/developerworks/cn/java/j-lo-asm30/index.html).\n\n这篇文章的发表时间是`2007年7月25日`。距今已十年有余。虽然很老，但是本质没变。最新的ASM版本是`7.0`. \n\n与其他的`Java bytecode frameworks`相比，ASM就是以性能著称。从其[官网](https://asm.ow2.io/)对其历史的介绍，就可窥得一斑。\n```\nASM项目由Eric Bruneton于2000年在INRIA博士期间创建。那时它只是一个代码生成器（没有ClassReader，没有访问者概念）。java.lang.reflect.Proxy在JDK 1.3中发布类之前，它用于生成动态存根和代理类 。这些动态类用于向用户组件透明地添加非功能属性（日志记录，持久性，复制等）。\n后来添加了访问者的想法和ClassReader概念，以便能够转换现有的类。需要将非功能代码直接插入用户类，而不是在中间代理中插入（以获得更好的性能）。这些新功能由Eric Bruneton在法国电信研发部门（现为Orange Labs）获得博士学位后设计和实施，以实现Fractal组件模型。\nASM项目于2002年在开源中发布，与Fractal项目同时发布。从那时起，该项目已经做了许多外部贡献。最重要的贡献者现在是ASM团队的一部分，即Eugene Kuleshov（自2003年起），Andrei Loskutov（自2004年起）和RémiForax（自2008年起）。\n```\n\n其使用非常简单，主线如下：\n```\n* 用户通过继承ClassAdaptor(实现了ClassVisitor接口)，定义扩展方法\n* ClassAdaptor可传入实现了ClassVisitor的对象，形成职责链\n* 职责链的最底层是一个ClassWriter, 其实现了ClassVisitor接口\n* ClassReader是执行入口类，通过accept方法接受一个职责链入口(实现了ClassVisitor的对象)。\n```\n\n相关设计模式：\n```\n* 访问者模式\n* 责任链模式\n* 适配器模式\n\n```\n","tags":["java"]},{"title":"做最好的自己","url":"/2018/04/15/做最好的自己/","content":"\n人人都想成功，但是真正成功的非常少。或者有些人只是短暂成功过，最后是以失败者的姿态退出舞台。\n\n成功，应该是一个持久的成功，而不是昙花一现。成功，不应该仅仅只是金钱物质上的成功。还应该有精神层面的成功。\n\n成功的必备条件：\n```\n树立理想：决定你努力的方向和成功的格局 ——> （战略）上不设限，顺势而为\n合理规划：制定通往理想的路径 ——> （战术）\n执行规划：实实在在的努力，80-20法则，10000小时定律，21天法则 ——> （执行）\n严格自律：提高规划执行效率，形成良好学习和生活习惯，延长上升时间和空间 ——>（持久）\n终生学习：不断学习，与时俱进。唯一不变的是变化 ——> (进步)\n```\n\n人生是一场马拉松。`you get the rule and you follow the rule`.\n\n那么问题来了，一个码农如何成功？\n\n一个码农，首先要列出码农界的成功人士名单。看他们是怎样的？研究一下，就像NBA的新秀们一样，要找到自己的模板或者榜样。向他们学习。\n\n或许，你成不了下一个\"乔丹\"，但是你可以成为第一个\"詹姆斯\"。\n","tags":["方法论"]},{"title":"学习之术","url":"/2018/04/03/学习之术/","content":"\n上高中时，读到过一篇文章，叫《凝练的过程: 抓住事物的本质》。它是惠普首位女CE0卡莉·菲奥莉娜2001年在斯坦福大学的演讲。文章中提到一个小故事，就是讲他们在斯坦福大学上学时，每个星期必须读完一本中世纪哲学的名著, 哲学名著都比较厚重，但是他们必须将这些哲学论述凝练成2页纸。\n        \n人类的知识体系和历史博大精深，浩如烟海，后人需要进行创造，就要站在前人巨人的肩膀上。先去学习他们，然后再去创造创新。那么多的知识，如果慢慢悠悠地去学习，怎么学的完理得清呢？必然是有方法的。事物的表象总是纷繁复杂，就像几千页的哲学名著。但是事物的本质却可以很简单的，只需要两页纸。但是这个从几千页到2页的凝练过程，正是我们打磨内化的过程。有的人一周就完成了(比如斯坦福大学的菲奥莉娜们)， 有的人可能需要花费很久很久时间，更有些人可能完成不了，中途放弃。\n\n针对如何高效学习，有以下思考：\n```\n1.系统学习，本源思考。（系统学习是成为专家的必由之路。从本源去理解事物，就能从本质去理解事物。了解事物为何诞生，如何发展。就能看到事物的未来发展之路。现在你是它的学习者，未来，或许你就是它的发展者，或者另一个事物的创造者）\n2.先握本质，再求细节。（细节繁琐，容易让人迷失。需要入乎其内，出乎其外，把握到其本质，然后再去理解细节，就能迅速掌握）\n3.掌握全局，精准打击。（遇到问题时，要具备全局的知识面和视野，才能提出全局的解决方案，而不是仅取得局部战争的胜利）\n4.精通典型，举一反三。（很多东西是类似的。无需重复学习。精通一个之后，略做思考，就能举一反三）\n```\n\n**演讲摘录**：\n```\n<生活的过程就是凝练的过程>\n我想先从我在“历史角”的经历说起。\n我在斯坦福所上的最有价值的课不是经济学，而是一个本科生的研究会“中世纪的基督教、伊斯兰教和犹太政治哲学”。每个星期我们必须读完一本中世纪哲学的名著，阿奎那、培根、阿伯拉尔，这些书都是很厚重的，我们每周怎么也得读1，000多页。周末的时候，我们必须把他们的哲学论述凝练成2页纸。这个过程就像是开始是20页，接着是10页，5页，最后是2页，一张纸的正反两面，这可不止是总结。它从众多观念中舍弃冗余，将其浓缩成最本质的内容。下个星期，你又得重新开始这个过程，不过面对的又是另外的长篇大论。\n这些哲学和思想肯定在我脑海中留下了印象。不过在凝练的过程也是一种练习，虽然艰苦，但真才实学就是由此产生的，这需要掌握惊人的机智和技巧。这么些年以来，我不断地运用它，用综合和凝练的思维活动到达事物的核心。\n```\n","tags":["方法论"]},{"title":"求知五步曲","url":"/2018/03/29/求知五部曲/","content":"\n关于求知，概之以五步曲：\n```\n第一步：初次谋面，握手寒暄。（入门） ——> Hello World\n\n第二步：系统学习，巨人之肩。（拜师） ——> 经典书籍 & OSS\n\n第三步：深度反思，大量实践。（苦练） ——> Code & Test\n\n第四步：领悟精髓，磨刀淬剑。（顿悟） ——> Think & Think Different\n\n第五步：不破不立，略有所成。（创造） ——> nobody or somebody\n```\n\n第二步和第三步是一个循环过程。在第二步和第三步上面没有足够的积累，没法到达第四步。或者说只是摸到第四步——略有顿悟。通常来说，大部分人都会停留在二三循环里面。\n\n人是一个惰性动物，必须具有突破力，爱思考，有积累，才会到达第四步。\n\n很多人年少成名，比如`Linus Benedict Torvalds`，又有巨多人空长百岁。其实人年少时很容易成功。因为够单纯。关键是要有高人指路，方向明确，直捣黄龙。\n\n要达到第四步，其实并不用花太多时间(人家年少就能成功，人家又花了多长时间呢？)。方法得到，积累得当，`十年磨一剑`肯定足够。\n\n第四步已达，第五步只是时机问题。\n\n求知之路，不论早晚，不论智商，没有终点。\n\n一言以蔽之，求知之轨迹，大抵五步曲尔。保持耐心！\n","tags":["方法论"]},{"title":"村眠","url":"/2018/02/14/村眠/","content":"\n<p>           \n<center>青翠绘图景，</center>\n<center>群鸟奏乐音。</center>\n<center>一觉自然醒，</center>\n<center>不觉鸡打鸣。</center>\n","tags":["人生"]},{"title":"行舟","url":"/2018/01/12/行舟/","content":"\n<p>           \n<center>时而风雨时而晴，小舟一叶向东行。</center>\n<center>美景荆棘交复现，何以淡泊与志明。</center>\n<center>历有风流人物事，大潮涌落现英姿。</center>\n<center>人生长海潜修行，明月永悬少年心。</center>\n","tags":["人生"]},{"title":"技术攻守道","url":"/2018/01/01/技术攻守道/","content":"\n<p>\n<center>守者，非守，乃修炼也。</center>\n<center>攻者，攻城，乃应用也。</center>\n<center>守而无攻，无用也。</center>\n<center>攻而无守，鲁莽也。</center>\n<center>守乎？何法？攻乎？何方？</center>\n<center>攻守之间，谋略之道也。</center>\n<center>屡攻，屡败？屡败，屡攻？</center>\n<center>攻守不止，持久之战也。</center>\n","tags":["方法论"]}]