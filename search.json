[{"title":"高并发架构设计","url":"/2018/11/30/高并发架构设计/","tags":["设计"]},{"title":"字节码生成自动化","url":"/2018/11/30/字节码生成自动化/","tags":["java"]},{"title":"Context类的设计","url":"/2018/11/30/Context类的设计/","tags":["设计"]},{"title":"面向工程 or 面向刨根","url":"/2018/11/30/面向工程-or-面向刨根/","tags":["方法论"]},{"title":"一把小锁走天下","url":"/2018/11/30/一把小锁走天下/","tags":["并发"]},{"title":"类加载小记","url":"/2018/09/30/类加载小记/","content":"\n类加载的控制逻辑(loadClass)： ——> java.lang.ClassLoader#loadClass\n\n* findLoadedClass // 检查是否已经被加载\n* loadClass // 使用parent class loader进行加载\n* findClass // 进行自定义的路径加载\n* resolveClass // 根据入参true或者false，进行动态链接。\n\n线程默认类加载器：\n\n* AppClassLoader ——> 继承URLClassLoader \n\n* 双亲委派模式：AppClassLoader ——> ExtClassLoader ——> bootClassLoader\n\nAppClassLoader的类层次结构：\n\n* ClassLoader\n* SecureClassLoader\n* URLClassLoader\n* AppClassLoader\n\n类加载的关键方法：\n\n* loadClass // 定义加载的控制逻辑\n* findClass // 定义寻找的控制逻辑\n* defineClass // 将二进制数据转换成一个class对象\n\n自定义类加载器举例：spring-boot-devtools#RestartClassLoader\n\n* 重写findClass、loadClass\n* 重写getResources、getResource、findResource\n\n<img max-width=100% src=\"https://upload-images.jianshu.io/upload_images/1401040-5a4e8cd04a742741.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500\"/>\n\n反序列化 VS 类加载：\n\n(1) 类加载：二进制到class——> java.lang.ClassLoader#defineClass\n```\n/**\n * 将一个ByteBuffer转换成一个class\n*/\nprotected final Class<?> defineClass(String name, java.nio.ByteBuffer b,\n                                     ProtectionDomain protectionDomain)\n    throws ClassFormatError\n{\n    int len = b.remaining();\n\n    // Use byte[] if not a direct ByteBufer:\n    if (!b.isDirect()) {\n        if (b.hasArray()) {\n            return defineClass(name, b.array(),\n                               b.position() + b.arrayOffset(), len,\n                               protectionDomain);\n        } else {\n            // no array, or read-only array\n            byte[] tb = new byte[len];\n            b.get(tb);  // get bytes out of byte buffer.\n            return defineClass(name, tb, 0, len, protectionDomain);\n        }\n    }\n\n    protectionDomain = preDefineClass(name, protectionDomain);\n    String source = defineClassSourceLocation(protectionDomain);\n    // native 方法\n    Class<?> c = defineClass2(name, b, b.position(), len, protectionDomain, source);\n    postDefineClass(c, protectionDomain);\n    return c;\n}\n```\n(2) 反序列化：类加载 + 实例化。\n\n默认类加载器 ——> java.io.ObjectInputStream#resolveClass\n```\nprotected Class<?> resolveClass(ObjectStreamClass desc)\n    throws IOException, ClassNotFoundException\n{\n    String name = desc.getName();\n    try {\n        // latestUserDefinedLoader() == AppClassLoader\n        return Class.forName(name, false, latestUserDefinedLoader());\n    } catch (ClassNotFoundException ex) {\n        Class<?> cl = primClasses.get(name);\n        if (cl != null) {\n            return cl;\n        } else {\n            throw ex;\n        }\n    }\n}\n```\n           \n\n配置自定义类加载器 ——> org.springframework.core#ConfigurableObjectInputStream\n  \n```\nprotected Class<?> resolveClass(ObjectStreamClass classDesc) throws IOException, ClassNotFoundException {\n   try {\n      if (this.classLoader != null) {\n         // Use the specified ClassLoader to resolve local classes.\n         return ClassUtils.forName(classDesc.getName(), this.classLoader);\n      }\n      else {\n         // Use the default ClassLoader...\n         return super.resolveClass(classDesc);\n      }\n   }\n   catch (ClassNotFoundException ex) {\n      return resolveFallbackIfPossible(classDesc.getName(), ex);\n   }\n}\n```\n","tags":["java"]},{"title":"设计模式之我见","url":"/2018/06/29/设计模式之我见/","content":"一个优秀的程序员必然要写的一手好代码。好代码的判定标准就是良好的可读性与扩展性。业界常提的`七大设计原则`和`23种设计模式`即是代码的最佳实践和设计指南。其实，设计模式也并非只有23种。请看[此处](https://github.com/iluwatar/java-design-patterns)。\n\n对于这些原则和设计模式，需要把握其本质，并应用到我们的生产实践当中。本质是什么呢？简而言之，即：`面向接口`。当我们针对一个实际问题进行代码设计时，实际上主要回答下面的问题：\n```\n需要设计几个接口？ —— 开放封闭原则：哪些地方可能需要扩展，哪些地方就定义接口\n接口的职责是什么？ —— 单一职责原则 & 接口隔离原则\n接口如何进行组合？ —— 组合/聚合复用原则 & 依赖倒置原则\n```\n\n可以说，设计模式正是基于这些好的设计原则对上面三个问题的经典回答。这些设计模式，其中有些基本是一样的，也不必死抠概念，刻意区分，关键是理解本质，灵活运用。最常用的是下面几个：\n\n```\nProxy Pattern\nAdapter Pattern\nFacade Pattern\nStategy Pattern\nObserver Pattern\nChain of Responsibility Pattern\nCommand Pattern\n```\n\n在我看来，`设计模式`还有一个重要作用，就是告诉我们怎么给接口`命名`。作为一名程序员，`命名`是一个技术活儿。这种`命名`是约定共识。当命名确定下来，职责划分也就确定了下来。\n\n以最常用的`Observer Pattern`为例，我们通常的命名会是`xxListener`, 又或者是`xxObserver`。只看这个名字，我们就知道这个类是干什么的了。\n","tags":["观点"]},{"title":"论观书","url":"/2018/01/30/论观书/","content":"\n对于观书，古人有诗：\n\n```\n观书有感二首\n\n[宋] 朱熹\n\n其一\n半亩方塘一鉴开，天光云影共徘徊。\n问渠那得清如许？为有源头活水来。\n\n其二\n昨夜江边春水生，艨艟巨舰一毛轻。\n向来枉费推移力，此日中流自在行。 \n```\n\n其一，强调多读好书。其二，量变引起质变。道理很简单，大家都懂。\n\n可是，为什么有的人成了大家，有的人成不了大家呢？可能的原因有以下几个：\n\n```\n1. 读的书太少，或者不爱读书。\n2. 读的书不对，不够系统，甚至读错书，被误人子弟而不自知。\n3. 缺少思考，囫囵吞枣，不得要领。\n4. 一直在重复学习。没有活水，只有死水。\n5. 缺少实践，读过既忘，毫无用处。\n6. 缺少总结，知识不能构成闭环系统。\n```\n\n如何解决？个人愚见：\n\n```\n1. 寻找经典书籍，进行阅读和学习。\n2. 反复思考和内化，实践，把握本质思想。\n3. 读书须有用武之地。必须大量生产实践，不断总结。\n4. 升华思想，创造创新，有足够积累。\n5. 可以尝试努力写出自己的好书。\n\n```\n","tags":["方法论"]},{"title":"求知五步曲","url":"/2017/12/29/求知五部曲/","content":"\n关于求知，概之以五步曲：\n\n```\n第一步：初次谋面，握手寒暄。（入门） ——> Hello World\n\n第二步：系统学习，巨人之肩。（拜师） ——> 经典书籍 & OSS\n\n第三步：深度反思，大量实践。（苦练） ——> Code & Test\n\n第四步：领悟精髓，磨刀淬剑。（顿悟） ——> Think & Think Different\n\n第五步：不破不立，一战登巅。（创造） ——> nobody or somebody\n```\n\n第二步和第三步是一个循环过程。在第二步和第三步上面没有足够的积累，没法到达第四步。或者说只是摸到第四步——略有顿悟。通常来说，大部分人都会停留在二三循环里面。\n\n人是一个惰性动物，必须具有突破力，爱思考，有积累，才会到达第四步。\n\n很多人年少成名，比如`Linus Benedict Torvalds`，又有巨多人空长百岁。其实人年少时很容易成功。因为够单纯。关键是要有高人指路，方向明确，直捣黄龙。\n\n要达到第四步，其实并不用花太多时间(人家年少就能成功，人家又花了多长时间呢？)。方法得到，积累得当，`十年磨一剑`肯定足够。\n\n第四步已达，第五步只是时机问题。\n\n求知之路，不论早晚，不论智商，没有终点。\n\n一言以蔽之，求知之轨迹，大抵五步曲尔。保持耐心！\n","tags":["方法论"]},{"title":"看你乘风破浪","url":"/2017/10/28/看你乘风破浪/","content":"\n```\n不管过去你有多优秀，还是有多路人\n\n不管过去你有多成功，还是有多失败\n\n过去的都是财富。过去，已成历史\n\n每一个今天都是新的起点\n\n\n或许，今天你比别人落后\n\n或许，你已蹉跎很多时间\n\n所以，你需要更加正确，更加努力\n\n才能追赶，甚至超越期望的自己\n\n\n人生是一场马拉松\n\n你的成就，只由你的终点衡量\n\n纵然岁月蹉跎，才觅得航船方向\n\n信你仍是追风少年\n\n\n看你乘风破浪\n\n\n```\n","tags":["自勉"]}]